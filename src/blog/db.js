/*
db.child('users/mg/name') => access JSON node database/users/mg/name

 Ways to save data
 set({})
 set(null) -> remove data
 update()
 push() -> add mew item to a collection
 transaction()
*/

export function createUsers(db) {
  const usersRef= db.child('users')

  // method 1, overwrites if exists
  usersRef.set({
    alanisawesome: {
      date_of_birth: 'June 23, 1912',
      full_name: 'Alan Turing'
    },
    gracehop: {
      date_of_birth: 'December 9, 1906',
      full_name: 'Grace Hopper'
    }
  })

  // method 2, modifies if exists
  usersRef.child('adalove').set({
    date_of_birth: 'December 10, 1815',
    full_name: 'Ada Lovelace'
  }, error => console.log('sets done'))
}

export function updateUser(db) {
  // single key path, each property specified is overwritten
  const hopperRef= db.child('users/gracehop')
  hopperRef.update({
    nickname: 'Amazing Grace'
  })

  // multipath update, allows modification of properties within objects
  const usersRef= db.child('users')
  usersRef.update({
    'alanisawesome/nickname': 'Alan The Machine',
    'adalove/nickname': 'The Enchantress of Numbers',
  }, error => console.log('updates done'))
}

export function pushPosts(db) {
  // autogenerated keys will be based on a timestamp
  const postsRef= db.child('posts')

  // pushing, then set
  const newPostRef= postsRef.push()
  newPostRef.set({
    author: 'gracehop',
    title: 'Announcing COBOL, a New Programming Language'
  })

  // chaining push and set
  postsRef.push().set({
    author: 'alanisawesome',
    title:'The Turing Machine'
  })

  // implicit chaining push and set, getting ref to post
  let postRef= postsRef.push({
    author: 'adalove',
    title: 'The Analytical Engine, fiction or future?'
  })

  console.log(postRef.key())

  // transactions
  const upvotesRef= {} //= postRef.get('upvotes')?
  upvotesRef.transaction(
    val => (val ||Â 0) + 1,
    () => console.log('completed')
  )
}

// firebase event functions
// .on(event, cb, err) => call cb whenever event occurs
// .once(event, cb, err) => call cb when event occurs the first time
// .off(event, cb) => remove cb for event
// .off(event) => remvoe all cb's for event
// .off() => turn off all events

export function postsSnapshot$(db) {
  const postSink= new Rx.Subject()
  const post$= postSink
    .map(v => v.val())
    .map(v => {
      if(v === null) return []
      let posts= []
      Object.keys(v).forEach(k => posts.push({
        key: k,
        ...v[k]
      }))
      return posts
    })

  db.child('posts')
    .on('value',
      v => postSink.onNext(v),
      e => postSink.onError(e)
    )

  return post$
}

export function createdPost$(db) {
  const postSink= new Rx.Subject()
  const post$= postSink
    .map(v => { return {key: v.key(), ...v.val()}})

  db.child('posts')
    .on('child_added',
      v => postSink.onNext(v),
      e => postSink.onError(e)
    )

  return post$
}

export function updatedPost$(db) {
  const postSink= new Rx.Subject()
  const post$= postSink
    .map(v => { return {key: v.key(), ...v.val()}})

  db.child('posts')
    .on('child_canged',
      v => postSink.onNext(v),
      e => postSink.onError(e)
    )

  return post$
}

export function removedPost$(db) {
  const postSink= new Rx.Subject()
  const post$= postSink
    .map(v => { return {key: v.key(), ...v.val()}})

  db.child('posts')
    .on('child_removed',
      v => postSink.onNext(v),
      e => postSink.onError(e)
    )

  return post$
}

// firebase querying
// orderByChild(prop), orderByKey(), orderByValue(), orderByPriority()
// limitToFirst(n), limitToLast(n),
// startAt(val), endAt(val), equalTo(val)

// ref.orderByChild(prop).on('child_added')
// if ojbect does not have prop it will have value null and come first

// ref.orderByChild(prop/prop/prop).on ... => order by a nested property

// use the .indexOn rule for props you want to order on prop in production
// use .valueOn when using orderByValue in production
